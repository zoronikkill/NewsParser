import os
import psycopg2
from datetime import datetime, timedelta
from telegram import (
    Update, 
    ReplyKeyboardMarkup, 
    KeyboardButton, 
    InlineKeyboardButton, 
    InlineKeyboardMarkup
)
from telegram.ext import (
    ApplicationBuilder, 
    CommandHandler, 
    CallbackQueryHandler, 
    MessageHandler, 
    filters, 
    ContextTypes
)


DB_HOST = os.getenv("DB_HOST", "localhost")
DB_PORT = os.getenv("DB_PORT", "5432")
DB_NAME = os.getenv("DB_NAME", "news")
DB_USER = os.getenv("DB_USER", "root")
DB_PASSWORD = os.getenv("DB_PASSWORD", "root")


def get_db_connection():
    return psycopg2.connect(
        host=DB_HOST,
        port=DB_PORT,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
    )


MAIN_MENU = [
    ["üîπ –í—Å–µ –ù–æ–≤–æ—Å—Ç–∏"],
    ["üóÇ –í—ã–±—Ä–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é"],
    ["üîç –ü–æ–∏—Å–∫ –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É"]
]

CATEGORY_MENU = [
    [KeyboardButton("üîπ –í—Å–µ –ù–æ–≤–æ—Å—Ç–∏")],
    [KeyboardButton("üóÇ –í—ã–±—Ä–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é")]
]


CATEGORY_KEYBOARD = InlineKeyboardMarkup([
    [InlineKeyboardButton("–ù–æ–≤–æ—Å—Ç–∏", callback_data="category_novosti")],
    [InlineKeyboardButton("–ü–æ–ª–∏—Ç–∏–∫–∞", callback_data="category_politics")],
    [InlineKeyboardButton("–≠–∫–æ–Ω–æ–º–∏–∫–∞", callback_data="category_economics")],
    [InlineKeyboardButton("–û–±—â–µ—Å—Ç–≤–æ", callback_data="category_society")],
    [InlineKeyboardButton("–ü—Ä–æ–∏—Å—à–µ—Å—Ç–≤–∏—è", callback_data="category_incident")],
    [InlineKeyboardButton("–ö—É–ª—å—Ç—É—Ä–∞ –∏ —Å–ø–æ—Ä—Ç", callback_data="category_culture-i-sport")]
])


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ.",
        reply_markup=ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
    )


async def news_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:",
        reply_markup=ReplyKeyboardMarkup(CATEGORY_MENU, resize_keyboard=True)
    )


async def all_news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("–°–µ–≥–æ–¥–Ω—è", callback_data="news_today")],
            [InlineKeyboardButton("5 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–Ω–µ–π", callback_data="news_5days")],
            [InlineKeyboardButton("N –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–Ω–µ–π", callback_data="news_custom_days")],
            [InlineKeyboardButton("–ó–∞–¥–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω", callback_data="news_period")]
        ])
    )


def fetch_news(query, params):
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(query, params)
    rows = cursor.fetchall()
    cursor.close()
    conn.close()
    return rows


async def select_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–æ–≤–æ—Å—Ç–µ–π:",
        reply_markup=CATEGORY_KEYBOARD
    )


async def handle_category_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    category_map = {
        "category_novosti": "novosti",
        "category_politics": "politics",
        "category_economics": "economics",
        "category_society": "society",
        "category_incident": "incident",
        "category_culture-i-sport": "culture-i-sport",
    }
    selected_category = category_map.get(query.data)

    if selected_category:
        context.user_data['selected_category'] = selected_category
        await query.message.reply_text(
            f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é: {selected_category}. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("–°–µ–≥–æ–¥–Ω—è", callback_data="period_today")],
                [InlineKeyboardButton("5 –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–Ω–µ–π", callback_data="period_5days")],
                [InlineKeyboardButton("N –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–Ω–µ–π", callback_data="period_custom_days")],
                [InlineKeyboardButton("–ó–∞–¥–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω", callback_data="period_custom_range")]
            ])
        )
    else:
        await query.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")


async def handle_period_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    selected_category = context.user_data.get('selected_category')

    if not selected_category:
        await query.message.reply_text("–û—à–∏–±–∫–∞! –ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –≤—ã–±—Ä–∞–Ω–∞.")
        return

    if query.data == "period_today":
        news = fetch_news(
            "SELECT title, date, link FROM news WHERE category ILIKE %s AND date >= %s ORDER BY date DESC",
            [f"%{selected_category}%", datetime.now().date()]
        )
        await send_news_response(query, news)

    elif query.data == "period_5days":
        days_ago = datetime.now() - timedelta(days=5)
        news = fetch_news(
            "SELECT title, date, link FROM news WHERE category ILIKE %s AND date >= %s ORDER BY date DESC",
            [f"%{selected_category}%", days_ago]
        )
        await send_news_response(query, news)

    elif query.data == "period_custom_days":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10):")
        context.user_data['await_days_for_category'] = True

    elif query.data == "period_custom_range":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD YYYY-MM-DD:")
        context.user_data['await_range_for_category'] = True


async def handle_news_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "news_today":
        news = fetch_news("SELECT title, date, link FROM news WHERE date >= %s", [datetime.now().date()])
        await send_news_response(query, news)

    elif query.data == "news_5days":
        days_ago = datetime.now() - timedelta(days=5)
        news = fetch_news("SELECT title, date, link FROM news WHERE date >= %s", [days_ago])
        await send_news_response(query, news)

    elif query.data == "news_custom_days":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10):")
        context.user_data['await_days'] = True

    elif query.data == "news_period":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD YYYY-MM-DD:")
        context.user_data['await_period'] = True


async def search_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞. –í—ã –º–æ–∂–µ—Ç–µ —Ç–∞–∫–∂–µ —É–∫–∞–∑–∞—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "`–∫–ª—é—á–µ–≤–æ–µ_—Å–ª–æ–≤–æ YYYY-MM-DD YYYY-MM-DD`\n\n"
        "–ü—Ä–∏–º–µ—Ä—ã: `\n–î–¢–ü\n–î–¢–ü 2024-12-01 2024-12-15`",
        parse_mode="Markdown"
    )
    context.user_data['await_search'] = True

async def custom_input_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    selected_category = context.user_data.get('selected_category')

    
    if context.user_data.get('await_days'):
        try:
            days = int(text)
            days_ago = datetime.now() - timedelta(days=days)
            news = fetch_news(
                "SELECT title, date, link FROM news WHERE date >= %s ORDER BY date DESC",
                [days_ago]
            )
            await send_news_response(update, news)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")
        context.user_data.pop('await_days', None)

    
    elif context.user_data.get('await_period'):
        try:
            start_date, end_date = text.split()
            news = fetch_news(
                "SELECT title, date, link FROM news WHERE date BETWEEN %s AND %s ORDER BY date DESC",
                [start_date, end_date]
            )
            await send_news_response(update, news)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD YYYY-MM-DD.")
        context.user_data.pop('await_period', None)

    
    elif context.user_data.get('await_days_for_category') and selected_category:
        try:
            days = int(text)
            days_ago = datetime.now() - timedelta(days=days)
            news = fetch_news(
                "SELECT title, date, link FROM news WHERE category ILIKE %s AND date >= %s ORDER BY date DESC",
                [f"%{selected_category}%", days_ago]
            )
            await send_news_response(update, news)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.")
        context.user_data.pop('await_days_for_category', None)

    
    elif context.user_data.get('await_range_for_category') and selected_category:
        try:
            start_date, end_date = text.split()
            news = fetch_news(
                "SELECT title, date, link FROM news WHERE category ILIKE %s AND date BETWEEN %s AND %s ORDER BY date DESC",
                [f"%{selected_category}%", start_date, end_date]
            )
            await send_news_response(update, news)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD YYYY-MM-DD.")
        context.user_data.pop('await_range_for_category', None)

    elif text == "üîç –ü–æ–∏—Å–∫ –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É":
        await search_menu(update, context)

    elif context.user_data.get('await_search'):
        try:
            parts = text.split()
            if len(parts) == 1:
                keywords = parts[0]
                start_date = None
                end_date = None
            elif len(parts) == 3:
                keywords = parts[0]
                start_date, end_date = parts[1], parts[2]
            else:
                raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥.")

            query = "SELECT title, date, link FROM news WHERE title ~* %s"
            params = [fr'\m{keywords}\M']

            if start_date and end_date:
                query += " AND date BETWEEN %s AND %s"
                params.extend([start_date, end_date])

            news = fetch_news(query, params)
            await send_news_response(update, news)
        except ValueError:
            await update.message.reply_text("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–≤–æ–¥. –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–∞ –∏, –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏, –¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD YYYY-MM-DD.")
        context.user_data.pop('await_search', None)


async def send_news_response(target, news):
    MAX_MESSAGE_LENGTH = 4000  
    if not news:
        await target.message.reply_text("–ù–µ—Ç –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.")
        return

    response = ""
    for row in news:
        news_item = f"üîπ {row[0]} ({row[1].strftime('%Y-%m-%d')}): {row[2]}\n\n"
        if len(response) + len(news_item) > MAX_MESSAGE_LENGTH:
            await target.message.reply_text(response)
            response = news_item
        else:
            response += news_item

    if response:
        await target.message.reply_text(response)


if __name__ == "__main__":
    BOT_TOKEN = os.getenv("BOT_TOKEN")
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.Regex("üì∞ –ù–æ–≤–æ—Å—Ç–∏"), news_menu))
    app.add_handler(MessageHandler(filters.Regex("üîπ –í—Å–µ –ù–æ–≤–æ—Å—Ç–∏"), all_news))
    app.add_handler(MessageHandler(filters.Regex("üóÇ –í—ã–±—Ä–∞—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é"), select_category))
    app.add_handler(CallbackQueryHandler(handle_news_query, pattern="news_.*"))
    app.add_handler(CallbackQueryHandler(handle_category_selection, pattern="category_.*"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, custom_input_handler))
    app.add_handler(CallbackQueryHandler(handle_period_selection, pattern="period_.*"))
    app.add_handler(MessageHandler(filters.Regex("üîç –ü–æ–∏—Å–∫ –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É"), search_menu))


    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    app.run_polling()
